import pandas as pd
import numpy as np
from sklearn.ensemble import IsolationForest
import joblib

# 1. Load Data
# You need to collect two files:
# normal.csv -> 5 minutes of idle/safe operation
# attack.csv -> 1 minute of simulated attacks (shaking, voltage drops)

try:
    normal_data = pd.read_csv('normal.csv')
    attack_data = pd.read_csv('attack.csv')
except FileNotFoundError:
    print("‚ùå Error: 'normal.csv' and 'attack.csv' not found.")
    print("   Please run the Data Collector firmware and save the Serial Output.")
    exit(1)

# Combined for training (Isolation Forest mostly needs normal data, but we can verify with attack)
# We only train on NORMAL data to learn what "Safe" looks like.
X_train = normal_data[['ax', 'ay', 'az', 'voltage']].values

# 2. Train Model
print("üß† Training Isolation Forest...")
clf = IsolationForest(random_state=42, contamination=0.01) # 1% expected anomalies in normal data
clf.fit(X_train)

# 3. Validation
print("\nüîç Validating...")
normal_preds = clf.predict(X_train)
attack_preds = clf.predict(attack_data[['ax', 'ay', 'az', 'voltage']].values)

n_errors = (normal_preds == -1).sum()
a_detected = (attack_preds == -1).sum()

print(f"Normal samples classified as Anomaly: {n_errors} / {len(normal_preds)}")
print(f"Attack samples correctly detected: {a_detected} / {len(attack_preds)}")

# 4. Export to C++ ( Simplified Decision Logic for ESP32 )
# Isolation Forest is hard to port directly to C without a heavy library.
# For a Hackathon/Microcontroller, a simpler approach is "Mahalanobis Distance" or "Min-Max Bounds" 
# IF the Isolation Forest is too complex. 

# Let's generate a "Bounds" based C header for simplicity and speed on ESP32.
# We will calculate the Mean and StdDev of normal data and define thresholds.

means = X_train.mean(axis=0)
stds = X_train.std(axis=0)

# Define 3-sigma bounds
lower_bounds = means - 3 * stds
upper_bounds = means + 3 * stds

header_content = f"""
#ifndef AI_MODEL_H
#define AI_MODEL_H

// Auto-generated by train_model.py
// Based on Statistical Thresholding (3-Sigma)

float means[] = {{ {', '.join(map(str, means))} }};
float stds[] = {{ {', '.join(map(str, stds))} }};
float lower_bounds[] = {{ {', '.join(map(str, lower_bounds))} }};
float upper_bounds[] = {{ {', '.join(map(str, upper_bounds))} }};

bool isAnomaly(int16_t ax, int16_t ay, int16_t az, int voltage) {{
    float input[] = {{ (float)ax, (float)ay, (float)az, (float)voltage }};
    
    // Check bounds
    for (int i = 0; i < 4; i++) {{
        if (input[i] < lower_bounds[i] || input[i] > upper_bounds[i]) {{
            return true; // Anomaly detected
        }}
    }}
    return false;
}}

#endif
"""

with open('model.h', 'w') as f:
    f.write(header_content)

print("\n‚úÖ Model exported to 'model.h'")
print("   Copy this file to your ESP32 firmware folder.")
